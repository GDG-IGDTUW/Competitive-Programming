# 4. Balanced Token Window

### Description

You are given a binary string of length n consisting only of characters 0 and 1.
You want to find the length of the longest contiguous substring such that:

The number of 0s is equal to the number of 1s.

### Input

- The first line contains an integer n (1 ≤ n ≤ 2×10⁵).
- The second line contains a binary string of length n.

### Output

Print the maximum possible length.

### Sample

**Input:**
```
6
110100
```

**Output:**
```
6
```


**code**
#include <iostream>
#include<unordered_map>
using namespace std;

int main() {
    int n;
    cin >> n;

  string s;
    cin >> s;

  unordered_map<int, int> firstIndex;
    int prefixSum = 0;
    int maxLen = 0;

   firstIndex[0] = -1;

  for (int i = 0; i < n; i++) {
        if (s[i] == '1')
            prefixSum += 1;
        else
            prefixSum -= 1;

  //If prefix sum seen before
       if (firstIndex.find(prefixSum) != firstIndex.end()) {
            maxLen = max(maxLen, i - firstIndex[prefixSum]);
        } else {
            // Store first occurrence
            firstIndex[prefixSum] = i;
        }
    }

  cout << maxLen << endl;
    return 0;
}
